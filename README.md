# 设计模式

一、单例模式01_single
------
## 1.饿汉式 

初始化的时候就加载 -> Hungry.java

## 2.懒汉式
需要的时候再去加载
对象加载过程
--	1.分配内存空间
--	2.执行构造方法，初始化对象
--	3.把这个对象只想这个空间
--	指令重排之后可能顺序错乱，会出现问题，导致先指向了地址，导致return的null

### 2.1. 文件说明
| 文件        |  说明  | 
| :--------:   | :-----:  |
| LazyMan01     | 最基础的单例 | 
| LazyMan02        |   双重检测锁模式，懒汉式单例，DCL懒汉式 加了个锁 |  
| LazyMan03        |    private volatile static LazyMan03 lazyMan02; 加volatile防止指令重排序    | 
| LazyMan04        |   反射破坏单例 |  
| LazyMan05        |   静态内部类单例 |  
| EnumSingle        |   枚举可以防止私有单例被破坏（constructor.newInstance();） |  

设计模式之原型模式：
1.实现一个接口，Cloneable
2.重写一个方法clone()
存在的问题就是colne的对象和源对象会指向共同的地址，分开需要在clone方法中深copy属性

设计模式之工厂模式：
simple：简单工厂：也叫静态工厂模式；若新加汽车需要更改代码；不符合OOP开闭原则，所以还有更好的办法及工厂方法模式
factorymethod：工厂方法模式：一个工厂接口负责造汽车，各自的工厂都需要实现这个接口来建造各自的东西

创建型模式：
	单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式
	
结构性模式：
	适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式
	
行为模式;
	模板方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，
	状态模式，策略模式，职责链模式，访问者模式

工厂模式：
	实现了创建者和调用者分离
	简单工厂模式  -- 用来生产同一等级结构中的任意产品（对于新增的新产品，需要覆盖已有代码）
	工厂方法模式  -- 用来生产统一等级中的固定产品（支持增加任意产品）
	抽象工厂模式  -- 围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂。

核心本质：实例化对象不适用new，用工厂方法代替
			将选择实现类，创建对象统一管理和控制，从而将调用者和实现类解耦
			
			
			
OOP七大原则：
	开闭原则：一个软件的实体应当对扩展开放，对修改关闭
	依赖倒转原则：要针对接口编程，不要针对实现编程
	迪米特法则：只与你直接的朋友通信，避免和陌生人通信
	
建造者模式：
	提供了一种创建对象的最佳方式
	定义：将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示
	主要作用：在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象，
	用户只需要给出指定复杂对象的类型和内容，建造者吗，模式负责按顺序创建复杂对象(把内部的建造过程和细节隐藏起来)

