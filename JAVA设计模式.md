# 23种设计模式

- 创建型模式
  - 单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式
- 结构型模式
  - 适配器模式，桥接模式，装饰模式，组合模式，外观模式(门面模式)，享元模式，代理模式
- 行为模式
  - 模板方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式，访问者模式

# 创建型模式

##  1.建造者模式

- 提供一种创建对象的最佳方式
- 定义：将一个复杂对象的构建和表示分离，使得同样的构建过程可以创建不同的表示
- 作用：在用户不知道对象的构建过程和细节的情况下就可以直接创建复杂的对象
  - 用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象（把内部的构建过程和细节隐藏起来）
- 例子：
  - 工厂（建造者模式）：负责造汽车（组装过程和细节在工厂内）
  - 汽车购买者：用户只要说出对应的型号可以直接购买
- 优点：
  - 建造和表示分离，实现解耦。客户端不必知道产品的具体细节
  - 将复杂产品的构建步骤分解在不同的方法中，创建过程更清晰
  - 具体的建造者之间是相互独立的，有利于系统的扩展。增加建造者无需改变源代码
- 缺点：
  - 构建的产品一般有很多共同点组成相似的部分，如果产品差异性很大则不适合使用建造者模式
  - 如果产品过于复杂，可能需要定义很多具体的建造者类来实现变化，导致系统变的很庞大。

## 2.原型模式

- 以某个对象为原型，copy为另一个新对象

```java
* 1.实现一个接口， Cloneable
* 2.重写一个方法， clone()
```

## 3.(简单)工厂模式

- 例子：交通工具工厂
  - 一个接口定义交通工具类型
  - 具体的车类型实现接口

## 4.抽象工厂模式

- 抽象工厂定义一系列的属性方法名，**形容词用接口，名词用抽象类**
- 不同的子类继承实现不同的扩展
- 产品族上扩展

5.工厂方法 FactoryMethod



# **结构性模式**

## 1.适配器模式

- 例子：
  - USB网线转换器
- 将一个类的接口转换成客户希望的另一个接口，Adapter模式使得原来的由于接口不兼容而不能一起工作的那些类可以在一起工作
- 角色分析：
  - 目标接口：客户期待的接口，目标可以是具体的或者抽象的类也可以是接口
  - 需要适配的类：需要适配的类或者适配者的类
  - 适配器：通过包装一个需要适配的对象，把原接口转成目标对象
- 优点：
  - 一个对象适配器可以吧多个不同的适配者适配到同一个目标
  - 可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏替换原则”适配者的子类也可以通过该适配器适配
- 缺点：
  - 不支持多继承，一次只能适配一个适配者类
  - 类适配器的目标抽象类只能为接口，不能为类
- 场景：
  - 系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码
  - 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

## 2.桥接模式 bridge

- 将抽象模式和实现部分分离，使他们都可以独立的变化。是一种对象结构性模式，又称为柄体模式或接口模式。
- 优点：
  - 桥接模式是比多继承更好解决方案，极大地减少了子类的个数，从而降低了管理和维护成本
  - 提高系统可扩展性，在两个维度之间任意扩展一个维度都不需要更改原有系统，符合开闭原则。
- 劣势：
  - 增加系统的理解和设计难度，聚合关联。
  - 需要正确识别抽象出维度独立的变化。
- 场景：
  - jvm虚拟机
  - JDBC驱动也是桥接模式应用之一

## 3.代理模式

- 例子：
  - 租房：房东-中介(代理)-租客
- 好处：
  - 使真实的角色操作更加纯粹，不用去关注一些公共的业务
  - 公共业务交给代理角色，实现业务分工
  - 公共业务发生扩展的时候，方便集中管理
- 缺点：
  - 一个真实角色就会产生一个代理角色 -- 动态代理（反射解决）

### 3.1.静态代理

- 角色分析：
  - 抽象角色：使用接口或者抽象类
  - 真实角色：被代理的角色
  - 代理角色：代理真实的角色。代理真实角色后一般做些附属操作
  - 客户：访问代理的人

### 3.2.动态代理

- 动态代理和静态代理角色一样

- 动态代理和静态代理是动态生成的

- 动态代理两大类：

  - 基于接口：JDK动态代理
  - 基于类：cglib
  - java字节码实现：javasist

  了解两个类：Proxy -- 生成动态代理实例

  ​						InvocationHandler -- 调用处理程序并返回实例结果

## 4.外观模式(门面模式)Facade

![image-20200704170321362](https://gitee.com/ubfirst/Typora/raw/master/img/image-20200704170321362.png)

--------------------->>>>

![image-20200704170508229](https://gitee.com/ubfirst/Typora/raw/master/img/image-20200704170508229.png)

- 定义一个一致性的接口，用以屏蔽内部子系统的细节，使用端只需要和此接口发生交互即可，无需关注子系统内部实现的细节。

- 一致性的接口联系各个系统
- 优点：
  - 屏蔽了子系统细节，降低了客户端对子系统使用的复杂性
  - 对客户端与子系统的耦合关系，让子系统内部模块更易维护和扩展
  - 通过更好的使用外观模式，可以更好的划分访问层次

## 5.享元模式  Flyweight Pattern

**介绍**

- 也叫做蝇量模式：运用共享技术有效的支持大量细粒度对象
- 常用底层开发，如数据库连接池
- 享元模式能够解决重复对象的内存浪费问题，当有大量相似对象的时候，需要缓存池。不需要总是创建对象，可以从缓存池中取。
- 最经典的应用是池技术

**原理图**

![image-20200704183003143](https://gitee.com/ubfirst/Typora/raw/master/img/image-20200704183003143.png)

- Flyweight是抽象的享元角色，产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现；（外部状态-频繁变化，内部状态-比较稳定的）
  - 外部状态 - 对象得以依赖的一个标记，是随着环境改变而改变的，不可共享的状态。
  - 内部状态 - 对象共享出来的信息，存储在享元对象内部但不会随着环境变化而变化。
- ConcreteFlyweight 具体的享元角色，具体的产品类，实现抽象角色相关业务
- UnsharedConcreteFlyweight  是不可共享的角色，一般不会出现在享元工厂
- FlyweightFactory 享元工厂类，用于构建一个池容器(集合)，同时提供从池中获取对象的方法

# 行为模式

## 1.策略模式

一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。

**应用实例：** 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。

**优点：** 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。

**缺点：** 1、策略类会增多。 2、所有策略类都需要对外暴露。

```
Comparator 为策略模式
```