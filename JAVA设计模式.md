# 23种设计模式

- 创建型模式
  - 单例模式，工厂模式，抽象工厂模式，建造者模式，原型模式
- 结构型模式
  - 适配器模式，桥接模式，装饰模式，组合模式，外观模式，享元模式，代理模式
- 行为模式
  - 模板方法模式，命令模式，迭代器模式，观察者模式，中介者模式，备忘录模式，解释器模式，状态模式，策略模式，职责链模式，访问者模式

##  1.建造者模式

- 提供一种创建对象的最佳方式
- 定义：将一个复杂对象的构建和表示分离，使得同样的构建过程可以创建不同的表示
- 作用：在用户不知道对象的构建过程和细节的情况下就可以直接创建复杂的对象
  - 用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象（把内部的构建过程和细节隐藏起来）
- 例子：
  - 工厂（建造者模式）：负责造汽车（组装过程和细节在工厂内）
  - 汽车购买者：用户只要说出对应的型号可以直接购买
- 优点：
  - 建造和表示分离，实现解耦。客户端不必知道产品的具体细节
  - 将复杂产品的构建步骤分解在不同的方法中，创建过程更清晰
  - 具体的建造者之间是相互独立的，有利于系统的扩展。增加建造者无需改变源代码
- 缺点：
  - 构建的产品一般有很多共同点组成相似的部分，如果产品差异性很大则不适合使用建造者模式
  - 如果产品过于复杂，可能需要定义很多具体的建造者类来实现变化，导致系统变的很庞大。

## 2.原型模式

- 以某个对象为原型，copy为另一个新对象

```java
* 1.实现一个接口， Cloneable
* 2.重写一个方法， clone()
```

## **结构性模式**

## 3.适配器模式

- 例子：
  - USB网线转换器
- 将一个类的接口转换成客户希望的另一个接口，Adapter模式使得原来的由于接口不兼容而不能一起工作的那些类可以在一起工作
- 角色分析：
  - 目标接口：客户期待的接口，目标可以是具体的或者抽象的类也可以是接口
  - 需要适配的类：需要适配的类或者适配者的类
  - 适配器：通过包装一个需要适配的对象，把原接口转成目标对象
- 优点：
  - 一个对象适配器可以吧多个不同的适配者适配到同一个目标
  - 可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏替换原则”适配者的子类也可以通过该适配器适配
- 缺点：
  - 不支持多继承，一次只能适配一个适配者类
  - 类适配器的目标抽象类只能为接口，不能为类
- 场景：
  - 系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码
  - 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

## 4.桥接模式 bridge

- 将抽象模式和实现部分分离，使他们都可以独立的变化。是一种对象结构性模式，又称为柄体模式或接口模式。
- 优点：
  - 桥接模式是比多继承更好解决方案，极大地减少了子类的个数，从而降低了管理和维护成本
  - 提高系统可扩展性，在两个维度之间任意扩展一个维度都不需要更改原有系统，符合开闭原则。
- 劣势：
  - 增加系统的理解和设计难度，聚合关联。
  - 需要正确识别抽象出维度独立的变化。
- 场景：
  - jvm虚拟机
  - JDBC驱动也是桥接模式应用之一

## 5.代理模式

- 例子：
  - 租房：房东-中介(代理)-租客
- 好处：
  - 使真实的角色操作更加纯粹，不用去关注一些公共的业务
  - 公共业务交给代理角色，实现业务分工
  - 公共业务发生扩展的时候，方便集中管理
- 缺点：
  - 一个真实角色就会产生一个代理角色 -- 动态代理（反射解决）

### 5.1.静态代理

- 角色分析：
  - 抽象角色：使用接口或者抽象类
  - 真实角色：被代理的角色
  - 代理角色：代理真实的角色。代理真实角色后一般做些附属操作
  - 客户：访问代理的人

### 5.2.动态代理

- 动态代理和静态代理角色一样

- 动态代理和静态代理是动态生成的

- 动态代理两大类：

  - 基于接口：JDK动态代理
  - 基于类：cglib
  - java字节码实现：javasist

  了解两个类：Proxy -- 生成动态代理实例

  ​						InvocationHandler -- 调用处理程序并返回实例结果